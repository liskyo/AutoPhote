# AutoPhote 工業相機自動化拍攝系統 - 專案架構及程式碼分析

## 1. 專案概述 (Project Overview)
**AutoPhote** 是一個專為工業生產線設計的自動化拍攝與影像上傳系統。
該系統支援多台工業相機同時運作 (目前預設為 5 台)，提供即時預覽、批次拍攝、暫存檢視以及自動上傳至遠端伺服器的功能。

**核心功能：**
*   **多相機控制**：支援同時觸發多台相機 (目前為模擬模式 MockCamera)。
*   **非同步處理**：使用 ThreadPoolExecutor 進行並行拍攝，確保 UI 不卡頓。
*   **狀態監控**：即時顯示每台相機的狀態 (Ready, Busy, Success, Error)。
*   **背景上傳**：拍攝後的照片會先存於本地，再透過背景執行緒 (Background Thread) 自動重試並上傳至遠端儲存區。
*   **使用者介面**：提供大按鈕操作面板 (拍攝、確認、重拍) 及網格狀即時預覽。

---

## 2. 目錄結構 (Directory Structure)

```
AutoPhote/
├── main.py                  # 程式進入點 (Application Entry Point)
├── config.py                # 全域設定檔 (Global Configuration)
├── requirements.txt         # 專案依賴套件列表
├── hardware/                # 硬體控制層 (Hardware Abstraction Layer)
│   └── mock_camera.py       # 模擬相機實作 (可替換為真實相機驅動)
├── services/                # 業務邏輯服務層 (Business Logic Services)
│   ├── capture_manager.py   # 相機拍攝與流程管理器
│   ├── upload_manager.py    # 上傳管理器 (佇列處理)
│   └── file_service.py      # 檔案系統操作封裝
├── ui/                      # 使用者介面層 (User Interface)
│   └── dashboard.py         # 主儀表板 UI (Tkinter)
└── utils/                   # 工具函式庫 (Utilities)
    └── logger.py            # 日誌記錄設定
```

---

## 3. 核心模組程式碼分析 (Core Code Analysis)

### 3.1 全域設定 (config.py)
*   **功能**：管理所有路徑、相機數量、UI 設定及重試參數。
*   **關鍵邏輯**：
    *   `get_valid_path`: 檢查路徑是否存在，若遠端磁區 (如 `T:\`) 未掛載，會自動降級使用本地路徑，防止程式崩潰。
*   **主要參數**：
    *   `CAMERA_COUNT = 5`: 相機數量。
    *   `LOCAL_TEMP_BUFFER`: 本地暫存區路徑。
    *   `REMOTE_SERVER_STORAGE`: 遠端伺服器儲存路徑。

### 3.2 硬體層 (hardware/mock_camera.py)
*   **功能**：定義相機介面並提供模擬實作。
*   **MockCamera 類別**：
    *   `connect/disconnect`: 模擬硬體連線延遲。
    *   `grab_image`: 產生帶有雜訊與文字 (Time, ID) 的假影像，用於測試 UI 顯示與檔案存檔流程。
*   **擴充性**：
    *   若要接真實相機 (如 Hikvision, Basler)，需繼承 `CameraBase` 並實作真實 SDK 的呼叫，且需在此加入 IP 設定 (目前尚未實作 IP config)。

### 3.3 拍攝管理服務 (services/capture_manager.py)
*   **功能**：協調多台相機的初始化、觸發與存檔。
*   **核心機制**：
    *   **ThreadPoolExecutor**：使用 `max_workers=CAMERA_COUNT` 建立執行緒池，確保所有相機並行拍攝 (Parallel Capture)，互不等待。
    *   **Callback 機制**：透過 `update_cam_status_callback` 與 `update_cam_image_callback` 將底層狀態即時回傳給 UI。
    *   **兩階段拍攝流程**：
        1.  `trigger_batch_capture(save_now=False)`: 僅拍攝並暫存於記憶體 (`pending_captures`)，供 UI 預覽 (Review 狀態)。
        2.  `confirm_save()`: 使用者確認後，才將記憶體中的影像寫入硬碟並加入上傳佇列。
        3.  `discard_capture()`: 清除記憶體暫存，重置相機狀態。

### 3.4 上傳管理服務 (services/upload_manager.py)
*   **功能**：負責將本地檔案移動至遠端伺服器。
*   **核心機制**：
    *   **Producer-Consumer 模式**：使用 `queue.Queue` 接收待上傳檔案路徑。
    *   **Daemon Thread**：啟動一個背景執行緒 (`_process_queue`) 不斷監聽佇列。
    *   **重試機制 (Retry Logic)**：上傳失敗時會自動重試 (`MAX_RETRIES` 次)，並模擬網路延遲，若最終失敗則保留本地檔案並記錄 Error Log。

### 3.5 使用者介面 (ui/dashboard.py)
*   **架構**：使用 Python 內建 GUI 庫 **Tkinter**。
*   **主要元件**：
    *   **DashboardApp**：主視窗類別。
    *   **Grid Layout**：動態計算 Grid (3欄x2列) 以適應 5 台相機，並支援視窗縮放 (Responsive)。
    *   **Canvas**：用於顯示影像預覽，並實作了 `_redraw_canvas` 以保持長寬比 (Aspect Ratio) 的縮放。
    *   **Event Binding**：綁定鍵盤快捷鍵 (Space=拍照, Enter=確認, Esc=重拍) 與滑鼠點擊 (點擊影像全螢幕放大)。
*   **全螢幕放大功能**：`show_enlarged_image` 會開啟一個新的 `Toplevel` 視窗並設為全螢幕，方便作業員細看瑕疵。

### 3.6 主程式 (main.py)
*   **功能**：系統組裝與啟動 (Dependency Injection)。
*   **流程**：
    1.  建立資料夾 (FileService)。
    2.  初始化共用佇列 (Queue) 與 UI Root。
    3.  實例化 `CaptureManager` 與 `UploadManager`，並注入 UI Callback 函式。
    4.  綁定 UI 按鈕事件 (Snap/Confirm/Retake) 到 Manager 的對應方法。
    5.  啟動背景服務並進入主迴圈 (`root.mainloop`)。

---

## 4. 運作資料流 (Data Flow)

1.  **使用者操作**：點擊 [拍照] 或按空白鍵。
2.  **觸發 (Trigger)**：`Main` -> `CaptureManager` 啟動多執行緒。
3.  **拍攝 (Capture)**：`MockCamera` 生成影像 -> 回傳 PIL Image。
4.  **顯示 (Display)**：Callback 觸發 UI 更新 Canvas 顯示預覽圖 (狀態: Review)。
5.  **使用者確認**：點擊 [確認]。
6.  **存檔 (Save)**：`CaptureManager` 將影像寫入 `temp_buffer` (狀態: Success)。
7.  **排程 (Queue)**：檔案路徑被 `put` 進 `upload_queue`。
8.  **上傳 (Upload)**：`UploadManager` 取出路徑 -> 移動檔案至 `REMOTE_SERVER_STORAGE`。

---

## 5. 待優化與擴充建議 (Future Improvements)

1.  **實作真實相機 IP 設定**：
    *   目前使用 MockCamera，若要介接真實 IP 相機，需在 `config.py` 新增 `CAMERA_IPS` 字典。
    *   在 `CaptureManager` 初始化時讀取對應 IP 並傳入相機驅動。
2.  **異常處理強化**：
    *   目前若遠端斷線，檔案會留在本地。可增加一個「重試按鈕」或「排程任務」在網路恢復後自動上傳積壓檔案。
3.  **設定檔外部化**：
    *   將 `config.py` 改為讀取 `settings.ini` 或 `config.json`，方便在不修改程式碼的情況下調整路徑或 IP。
